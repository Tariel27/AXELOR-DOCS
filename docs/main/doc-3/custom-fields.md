Начиная с Axelor Open Platform v5, мы теперь можем динамически добавлять настраиваемые поля в модели предметной области во время выполнения.

[](#models)Модели
-----------------

Пользовательские поля реализуются с использованием `JSON`поддержки типов данных из базовой базы данных. Поддерживаются все три официально поддерживаемые базы данных (PostgreSQL, MySQL и Oracle).

Модель предметной области (сущность) может иметь настраиваемые поля, если для нее `jsonAttr="true"` определен атрибут или `string`поле с расширением `json="true"`.

Вот некоторые примеры:

    <entity name="Product" jsonAttr="true">
      <string name="name" required="true" unique="true" min="2" />
      ...
    </entity>

xml![копировать значок](../../../../_/img/octicons-16.svg#view-clippy)Скопировано!

или

    <entity name="Product">
      <string name="name" required="true" unique="true" min="2" />
      ...
      <string name="attrs" title="Attributes" json="true" />
    </entity>

xml![копировать значок](../../../../_/img/octicons-16.svg#view-clippy)Скопировано!

Если мы предоставим `jsonAttr="true"`, что является значением по умолчанию, поле `string`с именем `"attrs"`автоматически генерируется в классе сущности, который аналогичен второму примеру.

Имя поля `attrs`теперь зарезервировано для определения поля json для хранения значений настраиваемого поля.

Мы также можем определить несколько полей json в модели домена:

    <entity name="Contact">
      <string name="name" required="true" unique="true" min="2" />
      ...
      <string name="customAttrs" title="Custom Attributes" json="true" />
      <string name="extraAttrs" title="Extra Attributes" json="true" />
    </entity>

xml![копировать значок](../../../../_/img/octicons-16.svg#view-clippy)Скопировано!

[](#views)Взгляды
-----------------

Если у сущности есть `attrs`поле, представления `form`и `grid`могут автоматически отображать настраиваемые поля. В противном случае для полей json с разными именами нам придется включить эти поля в поле зрения:

    <form ...>
      ...
      <panel title="Attributes">
        <field name="attrs" colSpan="12" />
      </panel>
    </form>

xml![копировать значок](../../../../_/img/octicons-16.svg#view-clippy)Скопировано!

Все настраиваемые поля, определенные для данного поля json, будут видны внутри этого виджета панели. Однако видимость в виде сетки контролируется `Show in grid`флагом, который мы увидим в следующем разделе.

[](#define-fields)Определить поля
---------------------------------

Настраиваемые поля определяются динамически во время выполнения с использованием графического интерфейса. Все определенные поля доступны из **администрирования.**  **Управление моделями**  **Пользовательские поля** .

На изображении ниже показано представление сетки, в котором перечислены все определенные настраиваемые поля:

![сетка настраиваемых полей](../_images/custom-fields-grid.png)

Рисунок 1. Пользовательские поля (сетка)

На изображении ниже показано представление формы для создания/редактирования настраиваемых полей:

![форма настраиваемых полей](../_images/custom-fields-form.png)

Рисунок 2. Настраиваемые поля (форма)

### [](#properties)Характеристики

Пользовательские поля сохраняются в виде `com.axelor.meta.db.MetaJsonField`записей. Определены следующие поля:



Имя

Описание

`name`

название настраиваемого поля (обязательно)

`title`

отображаемый заголовок

`type`

тип поля, поддерживаемые типы см. ниже.

`defaultValue`

значение по умолчанию для поля

`model`

полное имя модели, для которой определено поле

`modelField`

имя поля json, в котором определено это настраиваемое поле (например `attrs`)

`selection`

имя списка выбора, если поле является полем выбора

`widget`

альтернативный виджет для использования

`help`

короткая помощь

`showIf`

условное выражение js, чтобы показать/скрыть поле

`hideIf`

условное выражение js, чтобы показать/скрыть поле

`requiredIf`

условное выражение js, чтобы сделать поле обязательным

`readonlyIf`

условное выражение js, чтобы сделать поле доступным только для чтения

`hidden`

скрывать ли поле по умолчанию\`

`required`

является ли поле обязательным

`readonly`

доступно ли поле только для чтения

`nameField`

использовать ли это поле в качестве поля имени

`visibleInGrid`

должно ли поле быть видимым в виде сетки

`minSize`

минимальный размер стоимости

`maxSize`

максимальный размер стоимости

`scale`

масштаб для полей десятичного типа

`precision`

точность для полей десятичных типов

`regex`

регулярное выражение для проверки значения поля

`sequence`

заказ в автоматически созданном виде

`targetModel`

если это реляционное поле, полное имя целевой модели.

`valueExpr`

простое выражение js для вычисления значения

`enumType`

полное имя перечисления, если это поле типа перечисления

`formView`

если это реляционное поле, представление формы, которое будет использоваться для редактора всплывающих окон.

`gridView`

если это реляционное поле, представление сетки, которое будет использоваться для виджета списка и селектора

`domain`

фильтр домена для реляционных полей

`onChange`

действия для вызова при изменении поля

`onClick`

действия для вызова при нажатии на поле (кнопка)

### [](#types)Типы

Поддерживаются следующие типы настраиваемых полей:



Тип

Отображаемое имя

Описание

`string`

Нить

Для строковых полей

`integer`

Целое число

Для целочисленных полей

`decimal`

Десятичная дробь

Для десятичных полей

`boolean`

логическое значение

Для полей полей

`date`

Дата

Для полей даты

`datetime`

ДатаВремя

Для полей даты и времени

`time`

Время

Для полей времени

`panel`

Панель

Виртуальное поле для создания нового виджета панели для последующих полей.

`enum`

Перечисление

Для полей перечисления

`button`

Кнопка

Виртуальное поле для создания виджета кнопки (с `onClick`действием)

`separator`

Разделитель

Виртуальный виджет для создания виджета-разделителя

`many-to-one`

МногиеToОдин

Для отношений ManyToOne

`many-to-many`

МногиеToМногие

Для отношений ManyToMany

`one-to-many`

Один ко многим

На самом деле это то же самое, что и отношение ManyToMany, но используется виджет OneToMany.

[](#predefined-fields)Предопределенные поля
-------------------------------------------

Иногда нам может потребоваться заранее определить несколько настраиваемых полей. Это можно сделать с помощью функции импорта данных. Вот пример правил импорта данных и формата ввода:

Входные данные

    <custom-fields for="com.axelor.sale.db.Product" on="attrs">
      <field name="color" selection="product.color.selection" />
      <field name="active" type="boolean" />
      <field name="price" type="decimal" />
      <field name="quantity" type="integer" />
      <field name="date" type="datetime" />
      <field name="seller" type="many-to-one" target="com.axelor.contact.db.Contact" />
    </custom-fields>

xml![копировать значок](../../../../_/img/octicons-16.svg#view-clippy)Скопировано!

Импортировать конфигурацию

    <bind node="custom-fields/field" type="com.axelor.meta.db.MetaJsonField"
      search="self.name = :name AND self.model = :model AND self.modelField = :modelField">
      <bind node="../@for" to="model" />
      <bind node="../@on" to="modelField" />
      <bind node="@name" to="name" />
      <bind node="@type" to="type" eval="type?:'string'" />
      <bind node="@target" to="targetModel" />
      <bind node="@selection" to="selection" />
      <bind node="@widget" to="widget" />
    </bind>

xml![копировать значок](../../../../_/img/octicons-16.svg#view-clippy)Скопировано!

[](#context-aware-fields)Контекстно-зависимые поля
--------------------------------------------------

Пользовательские поля могут быть контекстно-зависимыми, то есть их можно показывать/скрывать в зависимости от значения какого-либо `ManyToOne`поля текущей записи.

Например, если мы определили настраиваемое поле `color`для `Product`модели и если `Product` модель имеет `ManyToOne`поле `category`, мы можем сделать `color`поле контекстным, установив:

*   `contextField (Value if)`к`category`

*   `contextFieldValue (Value)`до желаемого `category`значения (например `Computer`)


Поле `color`теперь контекстное и станет видимым, только если категория продукта равна `Computer`.

[](#context-aware-search)Контекстно-зависимый поиск
---------------------------------------------------

При расширенном поиске контекстные поля можно использовать для поиска по конкретному значению контекста. При поиске по значению контекста соответствующие контекстные поля станут видимыми в виде сетки.

На следующем изображении показан выбор контекстного поля в верхней части всплывающего окна расширенного поиска.

![всплывающее окно контекстного поиска](../_images/contextual-search-popup.png)

Рисунок 3. Контекстный расширенный поиск

На следующем изображении показаны результаты контекстного поиска. Вы можете видеть, что `Color`столбец становится видимым:

![результат контекстного поиска](../_images/contextual-search-result.png)

Рисунок 4. Результат контекстного поиска

[](#jpql-functions)JPQL-функции
-------------------------------

Функции JPQL можно использовать для извлечения и установки значений в настраиваемых полях:



Функция

Описание

`json_extract(jsonField, path…)` `json_extract_text(jsonField, path…)`

извлечь строку из указанного поля JSON

`json_extract_integer(jsonField, path…)`

извлечь целое число из указанного поля JSON

`json_extract_decimal(jsonField, path…)`

извлечь BigDecimal из указанного поля JSON

`json_extract_boolean(jsonField, path…)`

извлечь логическое значение из указанного поля JSON

`json_set(jsonField, path, value)`

установить значение в указанном поле JSON — _новое в версии 5.4._

Пример:

    UPDATE
      Product p
    SET
      p.attrs = json_set(p.attrs, 'seller.name', :value)
    WHERE
      json_extract_integer(p.attrs, 'seller', 'id') = 1

sql![копировать значок](../../../../_/img/octicons-16.svg#view-clippy)Скопировано!